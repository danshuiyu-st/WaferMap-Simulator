<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WaferMap 模拟器</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- Add SheetJS for Excel Export -->
    <script src="https://unpkg.com/xlsx/dist/xlsx.full.min.js"></script>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif; overflow: hidden; }
        
        /* Custom Scrollbar for the Sidebar */
        .custom-scroll::-webkit-scrollbar { width: 6px; height: 6px; }
        .custom-scroll::-webkit-scrollbar-track { background: transparent; }
        .custom-scroll::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 3px; }
        .custom-scroll::-webkit-scrollbar-thumb:hover { background: #94a3b8; }
        
        input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
        input[type="color"]::-webkit-color-swatch { border: none; border-radius: 4px; }

        .popup-window {
            animation: fadeIn 0.15s ease-out;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(5px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .modal-overlay { background-color: rgba(0, 0, 0, 0.5); backdrop-filter: blur(2px); }
    </style>
</head>
<body class="bg-gray-100 text-slate-800">

    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useLayoutEffect, useMemo } = React;

        // --- 1. 颜色工具 ---
        const PRESET_COLORS = [
            { name: 'Blue', fill: '#3b82f6', stroke: '#1d4ed8' },
            { name: 'Purple', fill: '#a855f7', stroke: '#7e22ce' },
            { name: 'Pink', fill: '#ec4899', stroke: '#be185d' },
            { name: 'Yellow', fill: '#eab308', stroke: '#a16207' },
            { name: 'Cyan', fill: '#06b6d4', stroke: '#0e7490' },
            { name: 'Green', fill: '#22c55e', stroke: '#15803d' },
            { name: 'Red', fill: '#ef4444', stroke: '#b91c1c' },
            { name: 'Orange', fill: '#f97316', stroke: '#c2410c' },
            { name: 'Slate', fill: '#64748b', stroke: '#334155' },
        ];

        const darkenColor = (hex, percent) => {
            let num = parseInt(hex.replace("#",""), 16),
            amt = Math.round(2.55 * percent),
            R = (num >> 16) - amt,
            B = ((num >> 8) & 0x00FF) - amt,
            G = (num & 0x0000FF) - amt;
            return "#" + (0x1000000 + (R<255?R<1?0:R:255)*0x10000 + (B<255?B<1?0:B:255)*0x100 + (G<255?G<1?0:G:255)).toString(16).slice(1);
        };

        const resolveColor = (colorIdx, customColor) => {
            if (customColor) return { fill: customColor, stroke: darkenColor(customColor, 20) };
            return PRESET_COLORS[colorIdx % PRESET_COLORS.length];
        };

        const DEFECT_COLOR = { fill: '#334155', stroke: '#1e293b' }; // Dark Slate

        // --- 2. 文本字典 ---
        const T = {
            title: "WaferMap模拟器", 
            goodDies: "Good Die", 
            edgeDies: "Edge Die", 
            defectDies: "Defect Die",
            exportGDS: "Export GDS",
            exportExcel: "Export Excel",
            
            drawingSettings: "Display Settings",
            unitSelection: "Unit",
            showLabels: "Labels",
            bgColor: "Map BG",

            waferParams: "Wafer Setup",
            size: "Diameter", 
            exclusion: "Edge Exclusion (mm)", 
            
            waferType: "Notch/Flat",
            notch: "Notch",
            flat: "Flat",
            flatLength: "Flat Length (mm)",
            orientation: "Orientation (deg)",

            singleMode: "Single Die", 
            shotMode: "Multi Die",
            
            shotOverlay: "Shot Grid",
            gridColor: "Color",
            lineStyle: "Style",
            solid: "Solid",
            dashed: "Dashed",

            chipParams: "Shot Definition",
            width: "Width", 
            height: "Height", 
            scribe: "Scribe", 
            scribeX: "Scribe X",
            scribeY: "Scribe Y",
            
            gridOffsetX: "Grid Offset X",
            gridOffsetY: "Grid Offset Y",
            shotOffsetX: "Offset X",
            shotOffsetY: "Offset Y",

            mpwSettings: "Die Groups",
            shotW: "Shot Width",
            shotH: "Shot Height",
            addDie: "Add Group",
            preview: "Preview",
            resultStats: "Summary",
            layerMap: "GDS Layers",
            colType: "Type",
            colGood: "Good",
            colEdge: "Edge",
            total: "Total",
            alignMode: "Alignment",
            center: "Center",
            centerDesc: "Center Aligned",
            vertex: "Cross",
            vertexDesc: "Cross Aligned",
            rows: "Rows",
            cols: "Cols",
            gapX: "Gap X",
            gapY: "Gap Y",
            
            defectDensity: "Defect Density (per mm²)",
            
            highDensityMsg: "⚠️ High Density",
            highDensityDesc: "Count > 100k. Drawing disabled for performance.",
            tooHeavyMsg: "⚠️ Calculation Limit",
            tooHeavyDesc: "Grid points > 2M. Calculation stopped to prevent crash.",
            resetView: "Reset View"
        };

        // --- 3. 图标组件 ---
        const Icons = {
            Disc: () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="10"/><circle cx="12" cy="12" r="3"/></svg>,
            Settings: () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0 .73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.1a2 2 0 0 1-1-1.72v-.51a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"/><circle cx="12" cy="12" r="3"/></svg>,
            Layout: () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect width="18" height="18" x="3" y="3" rx="2"/><path d="M3 9h18"/><path d="M9 21V9"/></svg>,
            Layers: () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="m12.83 2.18a2 2 0 0 0-1.66 0L2.6 6.08a1 1 0 0 0 0 1.83l8.58 3.91a2 2 0 0 0 1.66 0l8.58-3.9a1 1 0 0 0 0-1.83Z"/><path d="m22 17.65-9.17 4.16a2 2 0 0 1-1.66 0L2 17.65"/><path d="m22 12.65-9.17 4.16a2 2 0 0 1-1.66 0L2 12.65"/></svg>,
            Grid: () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect width="18" height="18" x="3" y="3" rx="2"/><path d="M3 9h18"/><path d="M3 15h18"/><path d="M9 3v18"/><path d="M15 3v18"/></svg>,
            Maximize: () => <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M8 3H5a2 2 0 0 0-2 2v3"/><path d="M21 8V5a2 2 0 0 0-2-2h-3"/><path d="M3 16v3a2 2 0 0 0 2 2h3"/><path d="M16 21h3a2 2 0 0 0 2-2v-3"/></svg>,
            Download: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" x2="12" y1="15" y2="3"/></svg>,
            Sheet: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect width="18" height="18" x="3" y="3" rx="2" ry="2"/><line x1="3" x2="21" y1="9" y2="9"/><line x1="3" x2="21" y1="15" y2="15"/><line x1="9" x2="9" y1="9" y2="21"/><line x1="15" x2="15" y1="9" y2="21"/></svg>,
            Plus: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M5 12h14"/><path d="M12 5v14"/></svg>,
            Trash2: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M3 6h18"/><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"/><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"/><line x1="10" x2="10" y1="11" y2="17"/><line x1="14" x2="14" y1="11" y2="17"/></svg>,
            FileCode: () => <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/><polyline points="14 2 14 8 20 8"/><path d="m10 13-2 2 2 2"/><path d="m14 17 2-2-2-2"/></svg>,
            AlertCircle: () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="10"/><line x1="12" x2="12" y1="8" y2="12"/><line x1="12" x2="12.01" y1="16" y2="16"/></svg>,
            RefreshCw: () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 2v6h-6"/><path d="M3 12a9 9 0 0 1 15-6.7L21 8"/><path d="M3 22v-6h6"/><path d="M21 12a9 9 0 0 1-15 6.7L3 16"/></svg>,
            ZoomIn: () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="11" cy="11" r="8"/><line x1="21" x2="16.65" y1="21" y2="16.65"/><line x1="11" x2="11" y1="8" y2="14"/><line x1="8" x2="14" y1="11" y2="11"/></svg>,
            ZoomOut: () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="11" cy="11" r="8"/><line x1="21" x2="16.65" y1="21" y2="16.65"/><line x1="8" x2="14" y1="11" y2="11"/></svg>,
            PenTool: () => <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M12 19l7-7 3 3-7 7-3-3z"/><path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"/><path d="M2 2l7.586 7.586"/><circle cx="11" cy="11" r="2"/></svg>,
            Crosshair: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="10"/><line x1="22" y1="12" x2="18" y2="12"/><line x1="6" y1="12" x2="2" y2="12"/><line x1="12" y1="6" x2="12" y2="2"/><line x1="12" y1="22" x2="12" y2="18"/></svg>,
            MousePointer: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M3 3l7.07 16.97 2.51-7.39 7.39-2.51L3 3z"/><path d="M13 13l6 6"/></svg>,
            X: () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>,
            Shuffle: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="16 3 21 3 21 8"></polyline><line x1="4" y1="20" x2="21" y2="3"></line><polyline points="21 16 21 21 16 21"></polyline><line x1="15" y1="15" x2="21" y2="21"></line><line x1="4" y1="4" x2="9" y2="9"></line></svg>
        };

        // --- 4. GDSII 引擎 ---
        class GDSWriter {
            constructor() { this.buffer = []; this.bufferLength = 0; }
            addRecord(cmd, dataType, data = []) {
                let length = 4;
                if (dataType === 1 || dataType === 2) length += data.length * 2;
                else if (dataType === 3) length += data.length * 4;
                else if (dataType === 6) { length += data.length; if (length % 2 !== 0) length++; }
                const buffer = new ArrayBuffer(length);
                const view = new DataView(buffer);
                view.setUint16(0, length); view.setUint8(2, cmd); view.setUint8(3, dataType);
                let offset = 4;
                if (dataType === 2) { data.forEach(val => { view.setInt16(offset, val); offset += 2; }); }
                else if (dataType === 3) { data.forEach(val => { view.setInt32(offset, val); offset += 4; }); }
                else if (dataType === 6) { for (let i = 0; i < data.length; i++) { view.setUint8(offset++, data.charCodeAt(i)); } if (length > 4 + data.length) view.setUint8(offset, 0); }
                this.buffer.push(buffer); this.bufferLength += length;
            }
            writeHeader() { this.addRecord(0x00, 0x02, [600]); }
            writeBgnLib() { const now = new Date(); const t = [now.getFullYear(), now.getMonth()+1, now.getDate(), now.getHours(), now.getMinutes(), now.getSeconds()]; this.addRecord(0x01, 0x02, [...t, ...t]); }
            writeLibName(name) { this.addRecord(0x02, 0x06, name); }
            writeUnits() { 
                const buffer = new ArrayBuffer(20); const view = new DataView(buffer);
                view.setUint16(0, 20); view.setUint8(2, 0x03); view.setUint8(3, 0x05); 
                const u1 = [0x3E, 0x41, 0x89, 0x37, 0x4B, 0xC6, 0xA7, 0xEF]; const u2 = [0x39, 0x44, 0xB8, 0x2F, 0xA0, 0x9B, 0x5A, 0x52];
                for(let i=0; i<8; i++) view.setUint8(4+i, u1[i]); for(let i=0; i<8; i++) view.setUint8(12+i, u2[i]);
                this.buffer.push(buffer);
            }
            writeBgnStr(name) { const now = new Date(); const t = [now.getFullYear(), now.getMonth()+1, now.getDate(), now.getHours(), now.getMinutes(), now.getSeconds()]; this.addRecord(0x05, 0x02, [...t, ...t]); this.addRecord(0x06, 0x06, name); }
            writePath(layer, dataType, width, xy) {
                this.addRecord(0x09, 0x00); this.addRecord(0x0D, 0x02, [layer]); this.addRecord(0x0E, 0x02, [dataType]); 
                this.addRecord(0x21, 0x02, [0]); this.addRecord(0x0F, 0x03, [width]); this.addRecord(0x10, 0x03, xy); this.addRecord(0x11, 0x00); 
            }
            writeBoundary(layer, dataType, xy) { this.addRecord(0x08, 0x00); this.addRecord(0x0D, 0x02, [layer]); this.addRecord(0x0E, 0x02, [dataType]); this.addRecord(0x10, 0x03, xy); this.addRecord(0x11, 0x00); }
            writeEndStr() { this.addRecord(0x07, 0x00); }
            writeEndLib() { this.addRecord(0x04, 0x00); }
            getBlob() { return new Blob(this.buffer, { type: 'application/octet-stream' }); }
        }

        // --- 5. UI 组件 ---
        const NumberInput = ({ label, value, onChange, step = "0.01", icon: Icon, suffix, className, children }) => (
            <div className={className}>
                <label className="block text-xs font-medium text-gray-500 mb-0.5 truncate" title={label}>{label}</label>
                <div className="flex gap-1">
                    <div className="relative rounded-md shadow-sm flex-1">
                        {Icon && (<div className="absolute inset-y-0 left-0 pl-2 flex items-center pointer-events-none text-gray-400"><Icon /></div>)}
                        <input type="number" value={value} onChange={(e) => onChange(e.target.value)} step="any" className={`focus:ring-indigo-500 focus:border-indigo-500 block w-full text-sm border-gray-300 rounded-md ${Icon ? 'pl-8' : 'pl-2'} pr-2 py-1 border transition-shadow`} placeholder="0" />
                        {suffix && (<div className="absolute inset-y-0 right-0 pr-2 flex items-center pointer-events-none"><span className="text-gray-400 text-sm">{suffix}</span></div>)}
                    </div>
                    {children}
                </div>
            </div>
        );

        const AlignmentSelector = ({ mode, onChange }) => (
            <div className="grid grid-cols-2 gap-2 mt-0.5">
                <button onClick={() => onChange('center')} className={`flex flex-col items-center justify-center p-1.5 rounded border transition-all ${mode === 'center' ? 'border-gray-500 bg-gray-50 text-gray-700 ring-1 ring-gray-500' : 'border-gray-200 hover:border-gray-300 text-gray-600 bg-white'}`}>
                    <div className="w-3 h-3 bg-gray-500 rounded-sm mb-0.5"></div><span className="text-[10px] font-bold text-gray-500 uppercase">{T.center}</span>
                </button>
                <button onClick={() => onChange('vertex')} className={`flex flex-col items-center justify-center p-1.5 rounded border transition-all ${mode === 'vertex' ? 'border-gray-500 bg-gray-50 text-gray-700 ring-1 ring-gray-500' : 'border-gray-200 hover:border-gray-300 text-gray-600 bg-white'}`}>
                    <div className="grid grid-cols-2 gap-0.5 w-3 h-3 mb-0.5"><div className="bg-gray-400 rounded-sm"></div><div className="bg-gray-400 rounded-sm"></div><div className="bg-gray-400 rounded-sm"></div><div className="bg-gray-400 rounded-sm"></div></div><span className="text-[10px] font-bold text-gray-500 uppercase">{T.vertex}</span>
                </button>
            </div>
        );

        const ViewControls = ({ unit, onUnitChange, showLabels, onShowLabelsChange, bgColor, onBgColorChange }) => (
            <div className="flex flex-col justify-end h-full pb-0.5">
                <div className="flex items-center justify-between gap-1 h-[28px]">
                     {/* Unit Switch */}
                    <div className="flex bg-gray-100 rounded p-0.5 border border-gray-200">
                        <button onClick={() => onUnitChange('mm')} className={`px-2 py-0.5 text-[11px] rounded ${unit==='mm' ? 'bg-white font-bold text-indigo-700 shadow-sm' : 'text-gray-400'}`}>mm</button>
                        <button onClick={() => onUnitChange('um')} className={`px-2 py-0.5 text-[11px] rounded ${unit==='um' ? 'bg-white font-bold text-indigo-700 shadow-sm' : 'text-gray-400'}`}>μm</button>
                    </div>
                    
                    <div className="w-px h-4 bg-gray-200 mx-1"></div>

                    {/* Labels Checkbox */}
                    <label className="flex items-center gap-1 cursor-pointer select-none" title={T.showLabels}>
                        <input type="checkbox" checked={showLabels} onChange={e => onShowLabelsChange(e.target.checked)} className="h-3 w-3 text-indigo-600 rounded border-gray-300" />
                        <span className="text-[11px] font-bold text-gray-500 uppercase">Lbl</span>
                    </label>

                     <div className="w-px h-4 bg-gray-200 mx-1"></div>

                     {/* BG Color */}
                     <label className="flex items-center gap-1 cursor-pointer select-none" title={T.bgColor}>
                        <div className="w-4 h-4 rounded border border-gray-300 overflow-hidden relative">
                             <input type="color" value={bgColor} onChange={e => onBgColorChange(e.target.value)} className="absolute -top-2 -left-2 w-8 h-8 p-0 border-0 cursor-pointer" />
                        </div>
                         <span className="text-[11px] font-bold text-gray-500 uppercase">BG</span>
                     </label>
                </div>
            </div>
        );

        // --- Modals ---
        const Modal = ({ title, children, onClose }) => (
            <div className="fixed inset-0 z-50 flex items-center justify-center modal-overlay" onClick={onClose}>
                <div className="bg-white rounded-lg shadow-2xl w-[90%] max-w-4xl max-h-[90vh] flex flex-col" onClick={e => e.stopPropagation()}>
                    <div className="flex justify-between items-center px-4 py-3 border-b border-gray-100">
                        <h3 className="text-sm font-bold text-gray-800">{title}</h3>
                        <button onClick={onClose} className="text-gray-400 hover:text-gray-600"><Icons.X /></button>
                    </div>
                    <div className="flex-1 overflow-auto p-4 custom-scroll">
                        {children}
                    </div>
                </div>
            </div>
        );

        const GDSLayerModal = ({ layers, onUpdate, onClose }) => {
            const [localLayers, setLocalLayers] = useState(layers);
            const handleChange = (key, val) => setLocalLayers(prev => ({ ...prev, [key]: parseInt(val) || 0 }));
            const handleSave = () => { onUpdate(localLayers); onClose(); };

            return (
                <div className="fixed inset-0 z-50 flex items-center justify-center modal-overlay" onClick={onClose}>
                    <div className="bg-white rounded-lg shadow-2xl w-[300px] p-4" onClick={e => e.stopPropagation()}>
                        <h3 className="text-sm font-bold text-gray-800 mb-4">GDS Layer Configuration</h3>
                        <div className="space-y-3 mb-4">
                            {Object.entries(localLayers).map(([k, v]) => (
                                <div key={k} className="flex justify-between items-center">
                                    <label className="text-xs font-medium text-gray-600 capitalize">{k}</label>
                                    <input type="number" value={v} onChange={e => handleChange(k, e.target.value)} className="w-16 border rounded px-2 py-1 text-xs text-right" />
                                </div>
                            ))}
                        </div>
                        <div className="flex justify-end gap-2">
                             <button onClick={onClose} className="px-3 py-1.5 text-xs text-gray-600 hover:bg-gray-100 rounded">Cancel</button>
                             <button onClick={handleSave} className="px-3 py-1.5 text-xs text-white bg-indigo-600 hover:bg-indigo-700 rounded font-medium">Save</button>
                        </div>
                    </div>
                </div>
            );
        };

        const DieListModal = ({ label, dies, unit, onClose }) => {
            const exportList = () => {
                const uStr = unit==='mm'?'(mm)':'(um)';
                const headers = ["Index", "Name", "Type", "Shot Col", "Shot Row", `Center X ${uStr}`, `Center Y ${uStr}`, `Width ${uStr}`, `Height ${uStr}`];
                const data = dies.map((d, i) => [
                    i+1, 
                    d.label || 'Single', 
                    d.status, // good, edge, defect
                    d.shotC, 
                    d.shotR, 
                    d.x, d.y, d.w, d.h 
                ]);
                const wb = XLSX.utils.book_new();
                const ws = XLSX.utils.aoa_to_sheet([headers, ...data]);
                XLSX.utils.book_append_sheet(wb, ws, `${label}_Dies`);
                XLSX.writeFile(wb, `Dies_${label}.xlsx`);
            };

            return (
                <Modal title={`Detailed Die List: ${label}`} onClose={onClose}>
                    <div className="flex justify-end mb-2">
                        <button onClick={exportList} className="flex items-center gap-2 bg-emerald-600 text-white px-3 py-1.5 rounded text-xs hover:bg-emerald-700">
                             <Icons.Sheet /> Export List to Excel
                        </button>
                    </div>
                    <div className="overflow-x-auto">
                        <table className="min-w-full divide-y divide-gray-200">
                            <thead className="bg-gray-50">
                                <tr>
                                    {["Index", "Name", "Type", "Shot Col", "Shot Row", `Center X (${unit})`, `Center Y (${unit})`, `Width (${unit})`, `Height (${unit})`].map((h, i) => (
                                        <th key={i} className="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider whitespace-nowrap">{h}</th>
                                    ))}
                                </tr>
                            </thead>
                            <tbody className="bg-white divide-y divide-gray-200">
                                {dies.map((d, i) => (
                                    <tr key={i} className={i%2===0 ? 'bg-white' : 'bg-gray-50'}>
                                        <td className="px-3 py-1.5 text-xs font-mono text-gray-500">{i+1}</td>
                                        <td className="px-3 py-1.5 text-xs font-medium text-gray-900">{d.label || 'Single'}</td>
                                        <td className="px-3 py-1.5 text-xs text-gray-500 capitalize">
                                            <span className={`px-1.5 py-0.5 rounded ${d.status==='good'?'bg-emerald-100 text-emerald-800': d.status==='edge'?'bg-orange-100 text-orange-800':'bg-slate-200 text-slate-800'}`}>
                                                {d.status}
                                            </span>
                                        </td>
                                        <td className="px-3 py-1.5 text-xs font-mono text-gray-500">{d.shotC}</td>
                                        <td className="px-3 py-1.5 text-xs font-mono text-gray-500">{d.shotR}</td>
                                        <td className="px-3 py-1.5 text-xs font-mono text-gray-500">{d.x.toFixed(3)}</td>
                                        <td className="px-3 py-1.5 text-xs font-mono text-gray-500">{d.y.toFixed(3)}</td>
                                        <td className="px-3 py-1.5 text-xs font-mono text-gray-500">{d.w.toFixed(3)}</td>
                                        <td className="px-3 py-1.5 text-xs font-mono text-gray-500">{d.h.toFixed(3)}</td>
                                    </tr>
                                ))}
                            </tbody>
                        </table>
                    </div>
                </Modal>
            );
        };

        // --- 6. 主程序 ---
        const WaferCalculator = () => {
            const [mode, setMode] = useState('single'); 
            const [unit, setUnit] = useState('mm'); 
            const [showLabels, setShowLabels] = useState(false); 
            const [mapBgColor, setMapBgColor] = useState('#0f172a');
            const [defectDensity, setDefectDensity] = useState(0); // defects per mm^2
            const [defectSeed, setDefectSeed] = useState(42); 
            const [gdsLayers, setGdsLayers] = useState({ wafer: 0, good: 1, edge: 2, defect: 3, shot: 10, center: 100 });

            const [showShotGrid, setShowShotGrid] = useState(true); 
            const [waferParams, setWaferParams] = useState({ diameter: '150', edgeExclusion: '3', type: 'notch', flatLength: '0', orientation: '0' }); 
            
            const [singleParams, setSingleParams] = useState({ width: '10', height: '10', scribe: '0.1', offsetMode: 'center', offsetX: '0', offsetY: '0' });
            // Added border properties
            const [singleDieSettings, setSingleDieSettings] = useState({ colorIdx: 0, customColor: null, borderColor: '#1d4ed8', borderWidth: 0.5 });

            const [shotGridConfig, setShotGridConfig] = useState({ color: '#3b82f6', style: 'dashed', width: 1.5 });

            const [shotParams, setShotParams] = useState({ width: '20', height: '20', scribeX: '0', scribeY: '0', offsetMode: 'center', offsetX: '0', offsetY: '0' });
            const [dieDefinitions, setDieDefinitions] = useState([
                { id: 1, label: 'Main', width: '3', height: '3', offsetX: '0', offsetY: '0', rows: 6, cols: 6, gapX: 0.1, gapY: 0.1, colorIdx: 0, customColor: null, borderColor: '#1d4ed8', borderWidth: 0.5 },
                { id: 2, label: 'Test', width: '1', height: '1', offsetX: '0', offsetY: '0', rows: 2, cols: 2, gapX: 18, gapY: 18, colorIdx: 3, customColor: null, borderColor: '#a16207', borderWidth: 0.5 },
            ]);

            const [stats, setStats] = useState({ summary: [], totalValid: 0, totalEdge: 0, totalDefect: 0, grossShots: 0, utilization: 0, isHighDensity: false, isTooHeavy: false });
            const [activeColorPicker, setActiveColorPicker] = useState(null); 
            
            // View State
            const [viewTransform, setViewTransform] = useState({ k: 1, x: 0, y: 0 });
            const [selectedDie, setSelectedDie] = useState(null); 
            const [popupPosition, setPopupPosition] = useState({ top: 0, left: 0 });
            
            // Modal States
            const [showDieListModalLabel, setShowDieListModalLabel] = useState(null);
            const [showLayerModal, setShowLayerModal] = useState(false);

            const [isDragging, setIsDragging] = useState(false);
            const lastMouseRef = useRef({ x: 0, y: 0 });
            const dragStartRef = useRef({ x: 0, y: 0 });

            const canvasRef = useRef(null);
            const containerRef = useRef(null);
            const calculatedDataRef = useRef({ dies: [], shots: [], waferR: 0, validR: 0, waferPoly: [], validPoly: [] });
            const calculateAndDrawRef = useRef(null);

            const parseDim = (val) => {
                const num = parseFloat(val) || 0;
                return unit === 'mm' ? num : num / 1000;
            };
            const parseNum = (val) => parseFloat(val) || 0;

            const labelWithUnit = (key) => {
                let text = T[key] || key;
                const uStr = unit === 'mm' ? '(mm)' : '(μm)';
                return `${text} ${uStr}`;
            };
            
            const pseudoRandom = (x, y, seed) => {
                 const s = Math.sin(x * 12.9898 + y * 78.233 + seed) * 43758.5453;
                 return s - Math.floor(s);
            };

            const handleUnitSwitch = (newUnit) => {
                if (newUnit === unit) return;
                const factor = newUnit === 'um' ? 1000 : 0.001; 
                setSingleParams(prev => ({
                    ...prev,
                    width: (parseFloat(prev.width) * factor).toFixed(4),
                    height: (parseFloat(prev.height) * factor).toFixed(4),
                    scribe: (parseFloat(prev.scribe) * factor).toFixed(4),
                    offsetX: (parseFloat(prev.offsetX) * factor).toFixed(4),
                    offsetY: (parseFloat(prev.offsetY) * factor).toFixed(4),
                }));
                setShotParams(prev => ({
                    ...prev,
                    width: (parseFloat(prev.width) * factor).toFixed(4),
                    height: (parseFloat(prev.height) * factor).toFixed(4),
                    scribeX: (parseFloat(prev.scribeX) * factor).toFixed(4),
                    scribeY: (parseFloat(prev.scribeY) * factor).toFixed(4),
                    offsetX: (parseFloat(prev.offsetX) * factor).toFixed(4),
                    offsetY: (parseFloat(prev.offsetY) * factor).toFixed(4),
                }));
                setDieDefinitions(prev => prev.map(d => ({
                    ...d,
                    width: (parseFloat(d.width) * factor).toFixed(4),
                    height: (parseFloat(d.height) * factor).toFixed(4),
                    offsetX: (parseFloat(d.offsetX) * factor).toFixed(4),
                    offsetY: (parseFloat(d.offsetY) * factor).toFixed(4),
                    gapX: (parseFloat(d.gapX) * factor).toFixed(4),
                    gapY: (parseFloat(d.gapY) * factor).toFixed(4),
                })));
                setUnit(newUnit);
            };

            const handleWaferChange = (key, val) => {
                if (key === 'diameter') {
                    const d = parseInt(val);
                    let fl = '0';
                    if (d === 100) fl = '30';
                    else if (d === 150) fl = '47.5';
                    setWaferParams(p => ({ ...p, diameter: val, flatLength: (p.type === 'flat' && fl !== '0') ? fl : p.flatLength }));
                } else if (key === 'type') {
                     setWaferParams(p => {
                        let fl = p.flatLength;
                        if (val === 'flat') {
                             const d = parseInt(p.diameter);
                             if (d === 100) fl = '30';
                             else if (d === 150) fl = '47.5';
                        }
                        return { ...p, type: val, flatLength: fl };
                     });
                } else {
                    setWaferParams(p => ({ ...p, [key]: val }));
                }
            };

            const handleSingleChange = (key, val) => setSingleParams(p => ({ ...p, [key]: val }));
            const handleShotChange = (key, val) => setShotParams(p => ({ ...p, [key]: val }));
            const updateDieDef = (id, field, val) => setDieDefinitions(prev => prev.map(d => d.id === id ? { ...d, [field]: val } : d));

            const handlePresetSelect = (id, idx) => {
                if (id === 'single') setSingleDieSettings(s => ({ ...s, colorIdx: idx, customColor: null, borderColor: PRESET_COLORS[idx].stroke }));
                else if (id === 'shotGrid') setShotGridConfig(s => ({ ...s, color: PRESET_COLORS[idx].stroke }));
                else setDieDefinitions(prev => prev.map(d => d.id === id ? { ...d, colorIdx: idx, customColor: null, borderColor: PRESET_COLORS[idx].stroke } : d));
            };
            
            const handleCustomColorSelect = (id, hex) => {
                if (id === 'single') setSingleDieSettings(s => ({ ...s, colorIdx: 0, customColor: hex }));
                else if (id === 'shotGrid') setShotGridConfig(s => ({ ...s, color: hex }));
                else setDieDefinitions(prev => prev.map(d => d.id === id ? { ...d, customColor: hex } : d));
            };

            const handleBorderColorSelect = (id, hex) => {
                if (id === 'single') setSingleDieSettings(s => ({ ...s, borderColor: hex }));
                else if (id === 'shotGrid') setShotGridConfig(s => ({ ...s, color: hex }));
                else setDieDefinitions(prev => prev.map(d => d.id === id ? { ...d, borderColor: hex } : d));
            };
            
            const handleBorderWidthChange = (id, val) => {
                 if (id === 'single') setSingleDieSettings(s => ({ ...s, borderWidth: parseFloat(val) || 0.5 }));
                 else if (id === 'shotGrid') setShotGridConfig(s => ({ ...s, width: parseFloat(val) || 1.5 }));
                 else setDieDefinitions(prev => prev.map(d => d.id === id ? { ...d, borderWidth: parseFloat(val) || 0.5 } : d));
            };
            
            const handleShotGridStyleChange = (val) => {
                 setShotGridConfig(s => ({ ...s, style: val }));
            };

            const handleWheel = (e) => {
                e.preventDefault();
                if (stats.isHighDensity || stats.isTooHeavy) return;
                const rect = canvasRef.current.getBoundingClientRect();
                const mx = e.clientX - rect.left - rect.width / 2;
                const my = e.clientY - rect.top - rect.height / 2;
                const factor = e.deltaY < 0 ? 1.1 : 0.9;
                const newK = Math.max(0.1, Math.min(viewTransform.k * factor, 50)); 
                const ratio = newK / viewTransform.k;
                const newX = mx - (mx - viewTransform.x) * ratio;
                const newY = my - (my - viewTransform.y) * ratio;
                setViewTransform({ k: newK, x: newX, y: newY });
            };

            const handleMouseDown = (e) => { 
                if (stats.isHighDensity || stats.isTooHeavy) return; 
                setIsDragging(true); 
                lastMouseRef.current = { x: e.clientX, y: e.clientY }; 
                dragStartRef.current = { x: e.clientX, y: e.clientY };
            };
            const handleMouseMove = (e) => {
                if (!isDragging) return;
                const dx = e.clientX - lastMouseRef.current.x;
                const dy = e.clientY - lastMouseRef.current.y;
                lastMouseRef.current = { x: e.clientX, y: e.clientY };
                setViewTransform(prev => ({ ...prev, x: prev.x + dx, y: prev.y + dy }));
            };
            
            const handleMouseUp = (e) => { 
                setIsDragging(false);
                const dist = Math.sqrt(Math.pow(e.clientX - dragStartRef.current.x, 2) + Math.pow(e.clientY - dragStartRef.current.y, 2));
                if (dist < 5) {
                    handleCanvasClick(e);
                }
            };

            useEffect(() => {
                const handleKeyDown = (e) => {
                    if (e.key === 'Escape') setSelectedDie(null);
                };
                const handleContextMenu = (e) => {
                    if (e.target === canvasRef.current) {
                        setSelectedDie(null);
                    }
                };

                window.addEventListener('keydown', handleKeyDown);
                document.addEventListener('contextmenu', handleContextMenu);

                return () => {
                    window.removeEventListener('keydown', handleKeyDown);
                    document.removeEventListener('contextmenu', handleContextMenu);
                }
            }, []);
            
            const handleCanvasClick = (e) => {
                if (!canvasRef.current || stats.isHighDensity || stats.isTooHeavy) return;
                const rect = canvasRef.current.getBoundingClientRect();
                const container = containerRef.current;
                const displaySizeW = container.clientWidth;
                const displaySizeH = container.clientHeight;
                const waferD = parseNum(waferParams.diameter);
                const R = waferD / 2;
                const baseScale = (Math.min(displaySizeW, displaySizeH) / 2) / (R * 1.05);
                const finalScale = baseScale * viewTransform.k;
                const mx = e.clientX - rect.left - (displaySizeW/2 + viewTransform.x);
                const my = e.clientY - rect.top - (displaySizeH/2 + viewTransform.y);
                const worldX = mx / finalScale;
                const worldY = -my / finalScale; 
                const clickedDie = calculatedDataRef.current.dies.find(d => 
                    worldX >= d.x - d.w/2 && worldX <= d.x + d.w/2 &&
                    worldY >= d.y - d.h/2 && worldY <= d.y + d.h/2
                );
                if (clickedDie) {
                    if (selectedDie && selectedDie.x === clickedDie.x && selectedDie.y === clickedDie.y) {
                        setSelectedDie(null);
                    } else {
                        setSelectedDie(clickedDie);
                    }
                } else {
                    setSelectedDie(null);
                }
            };
            
            const resetView = () => { setViewTransform({ k: 1, x: 0, y: 0 }); };

            const calculateAndDraw = () => {
                const canvas = canvasRef.current;
                const container = containerRef.current;
                if (!canvas || !container) return;
                
                const dpr = window.devicePixelRatio || 1;
                const displaySizeW = container.clientWidth;
                const displaySizeH = container.clientHeight;
                
                if (canvas.width !== displaySizeW * dpr || canvas.height !== displaySizeH * dpr) {
                    canvas.width = displaySizeW * dpr; canvas.height = displaySizeH * dpr;
                }
                
                const ctx = canvas.getContext('2d');
                ctx.setTransform(1, 0, 0, 1, 0, 0); 
                ctx.scale(dpr, dpr); 
                ctx.clearRect(0, 0, displaySizeW, displaySizeH);

                const waferD = parseNum(waferParams.diameter);
                const R = waferD / 2;
                const exclusion = parseNum(waferParams.edgeExclusion); // Directly parse mm
                const validR = Math.max(0, R - exclusion);
                const orientationDeg = parseNum(waferParams.orientation);
                const rotRad = orientationDeg * Math.PI / 180;

                // View Transform
                ctx.translate(displaySizeW / 2 + viewTransform.x, displaySizeH / 2 + viewTransform.y);
                const baseScale = (Math.min(displaySizeW, displaySizeH) / 2) / (R * 1.05);
                const finalScale = baseScale * viewTransform.k;
                ctx.scale(finalScale, -finalScale);

                // Draw Wafer
                const waferPoly = generateWaferOutline(R, waferParams.type, waferParams.flatLength, orientationDeg); 
                const validPoly = generateWaferOutline(validR, waferParams.type, waferParams.flatLength, orientationDeg); 

                ctx.beginPath();
                waferPoly.forEach((p, i) => i===0 ? ctx.moveTo(p.x, p.y) : ctx.lineTo(p.x, p.y));
                ctx.closePath();
                ctx.fillStyle = '#f8fafc'; ctx.fill(); 
                ctx.strokeStyle = '#94a3b8'; ctx.lineWidth = 1.5 / finalScale; ctx.stroke();

                ctx.beginPath();
                if (waferParams.type === 'flat') { validPoly.forEach((p, i) => i===0 ? ctx.moveTo(p.x, p.y) : ctx.lineTo(p.x, p.y)); } 
                else { ctx.arc(0, 0, validR, 0, 2 * Math.PI); }
                ctx.closePath();
                ctx.strokeStyle = '#ef4444'; ctx.lineWidth = 1 / finalScale; 
                ctx.setLineDash([5 / finalScale, 3 / finalScale]); ctx.stroke(); ctx.setLineDash([]);
                
                // NOTCH ARROW
                if (waferParams.type === 'notch') {
                    const notchAngle = -Math.PI/2 + rotRad;
                    
                    // Calculate sizes in World Units based on desired Screen Pixels (approx)
                    const fontSizeScreen = 15; 
                    const fontSize = fontSizeScreen / finalScale;
                    const arrowLength = 20 / finalScale; // Length of arrow in world units
                    const textPadding = 2 / finalScale;

                    // Coordinates
                    // Tip is at the Wafer Edge (plus a tiny gap so it doesn't touch exactly)
                    const tipR = R + (1/finalScale);
                    const tailR = tipR + arrowLength;
                    const textR = tailR + textPadding + (fontSize/2); // Center text slightly beyond arrow tail

                    const tipX = tipR * Math.cos(notchAngle);
                    const tipY = tipR * Math.sin(notchAngle);
                    
                    const tailX = tailR * Math.cos(notchAngle);
                    const tailY = tailR * Math.sin(notchAngle);

                    const textX = textR * Math.cos(notchAngle);
                    const textY = textR * Math.sin(notchAngle);

                    ctx.save();
                    ctx.strokeStyle = '#64748b'; // Slate-500
                    ctx.fillStyle = '#64748b';
                    ctx.lineWidth = 1 / finalScale;

                    // Draw Arrow Line (From Tail to Tip)
                    ctx.beginPath();
                    ctx.moveTo(tailX, tailY);
                    ctx.lineTo(tipX, tipY);
                    ctx.stroke();

                    // Draw Arrow Head (at Tip)
                    const headLen = 4 / finalScale;
                    const headAngle = Math.PI / 6; // 30 degrees
                    // Vector from Tail to Tip is inward. Angle is notchAngle + PI.
                    const arrowDir = notchAngle + Math.PI;

                    ctx.beginPath();
                    ctx.moveTo(tipX, tipY);
                    ctx.lineTo(
                        tipX + headLen * Math.cos(arrowDir - headAngle),
                        tipY + headLen * Math.sin(arrowDir - headAngle)
                    );
                    ctx.lineTo(
                        tipX + headLen * Math.cos(arrowDir + headAngle),
                        tipY + headLen * Math.sin(arrowDir + headAngle)
                    );
                    ctx.closePath();
                    ctx.fill();

                    // Draw Text (At Tail)
                    ctx.translate(textX, textY);
                    ctx.scale(1, -1); // Unflip Y for text
                    ctx.font = `italic ${fontSize}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    
                    ctx.fillText("Notch", 0, 0);

                    ctx.restore();
                }

                let layoutStepX, layoutStepY, startOffX, startOffY, shotW, shotH;

                if (mode === 'single') {
                    shotW = parseDim(singleParams.width); shotH = parseDim(singleParams.height);
                    layoutStepX = shotW + parseDim(singleParams.scribe); layoutStepY = shotH + parseDim(singleParams.scribe);
                    startOffX = (singleParams.offsetMode === 'vertex' ? layoutStepX / 2 : 0) + parseDim(singleParams.offsetX); 
                    startOffY = (singleParams.offsetMode === 'vertex' ? layoutStepY / 2 : 0) + parseDim(singleParams.offsetY);
                } else {
                    shotW = parseDim(shotParams.width); shotH = parseDim(shotParams.height);
                    layoutStepX = shotW + parseDim(shotParams.scribeX); layoutStepY = shotH + parseDim(shotParams.scribeY);
                    startOffX = (shotParams.offsetMode === 'vertex' ? layoutStepX / 2 : 0) + parseDim(shotParams.offsetX); 
                    startOffY = (shotParams.offsetMode === 'vertex' ? layoutStepY / 2 : 0) + parseDim(shotParams.offsetY);
                }

                if (layoutStepX <= 0.000001 || layoutStepY <= 0.000001) return;

                const maxCol = Math.ceil(R / layoutStepX) + 1; 
                const maxRow = Math.ceil(R / layoutStepY) + 1;
                
                const estimatedGridPoints = (maxCol * 2) * (maxRow * 2);
                if (estimatedGridPoints > 2000000) {
                    setStats(prev => ({ ...prev, isTooHeavy: true, isHighDensity: false }));
                    return; 
                }

                const isHighDensity = layoutStepX < 0.1 || layoutStepY < 0.1;
                
                const allDies = []; const allShots = []; let grossShots = 0;
                let hdTotalValid = 0; let hdTotalEdge = 0; let hdTotalDieArea = 0; const hdSummary = {}; 

                const cosR = Math.cos(-rotRad); 
                const sinR = Math.sin(-rotRad);

                // Track grid extents for axis positioning
                let gridMinX = Infinity, gridMaxX = -Infinity, gridMinY = Infinity, gridMaxY = -Infinity;

                for (let col = -maxCol; col <= maxCol; col++) {
                    for (let row = -maxRow; row <= maxRow; row++) {
                        const gridCenterX = col * layoutStepX + startOffX; 
                        const gridCenterY = row * layoutStepY + startOffY;
                        
                        // optimization: basic distance check
                        if (Math.sqrt(gridCenterX**2 + gridCenterY**2) > R + Math.max(layoutStepX, layoutStepY)) continue;

                        const shotCorners = [ {x: gridCenterX - shotW/2, y: gridCenterY - shotH/2}, {x: gridCenterX + shotW/2, y: gridCenterY - shotH/2}, {x: gridCenterX + shotW/2, y: gridCenterY + shotH/2}, {x: gridCenterX - shotW/2, y: gridCenterY + shotH/2}, ];
                        let isShotPartial = false;
                        for(let c of shotCorners) if (Math.sqrt(c.x**2 + c.y**2) <= R) isShotPartial = true;
                        if (!isShotPartial && Math.sqrt(gridCenterX**2 + gridCenterY**2) < Math.max(shotW, shotH)/2) isShotPartial = true;

                        if (isShotPartial) {
                            grossShots++; 
                            allShots.push({ x: gridCenterX, y: gridCenterY, w: shotW, h: shotH });
                            // Update extents based on shot presence
                            gridMinX = Math.min(gridMinX, col); gridMaxX = Math.max(gridMaxX, col);
                            gridMinY = Math.min(gridMinY, row); gridMaxY = Math.max(gridMaxY, row);
                        }

                        let dieGroups = [];
                        if (mode === 'single') { 
                            dieGroups.push({ typeId: 0, label: 'Single', w: shotW, h: shotH, relX: 0, relY: 0, rows: 1, cols: 1, gapX: 0, gapY: 0, colorIdx: singleDieSettings.colorIdx, customColor: singleDieSettings.customColor, borderColor: singleDieSettings.borderColor, borderWidth: singleDieSettings.borderWidth, shotC: col, shotR: -row }); 
                        } else { 
                            dieGroups = dieDefinitions.map(d => ({ 
                                typeId: d.id, label: d.label, 
                                w: parseDim(d.width), h: parseDim(d.height), 
                                relX: parseDim(d.offsetX), relY: parseDim(d.offsetY), 
                                rows: parseNum(d.rows) || 1, cols: parseNum(d.cols) || 1, 
                                gapX: parseDim(d.gapX) || 0, gapY: parseDim(d.gapY) || 0, 
                                colorIdx: d.colorIdx, customColor: d.customColor,
                                borderColor: d.borderColor, borderWidth: d.borderWidth,
                                shotC: col, shotR: -row
                            })); 
                        }

                        dieGroups.forEach(group => {
                            const totalArrW = group.cols * group.w + (group.cols - 1) * group.gapX;
                            const totalArrH = group.rows * group.h + (group.rows - 1) * group.gapY;
                            const startX = -totalArrW / 2 + group.w / 2;
                            const startY = -totalArrH / 2 + group.h / 2;
                            for(let r = 0; r < group.rows; r++) {
                                for(let c = 0; c < group.cols; c++) {
                                    const arrOffsetX = startX + c * (group.w + group.gapX);
                                    const arrOffsetY = startY + r * (group.h + group.gapY);
                                    const dieCenterX = gridCenterX + group.relX + arrOffsetX;
                                    const dieCenterY = gridCenterY + group.relY + arrOffsetY;
                                    const corners = [ { x: dieCenterX - group.w/2, y: dieCenterY - group.h/2 }, { x: dieCenterX + group.w/2, y: dieCenterY - group.h/2 }, { x: dieCenterX + group.w/2, y: dieCenterY + group.h/2 }, { x: dieCenterX - group.w/2, y: dieCenterY + group.h/2 } ];
                                    let isPhysicallyInside = true; let isEffectivelyInside = true;
                                    for (let cr of corners) {
                                        const d = Math.sqrt(cr.x**2 + cr.y**2);
                                        if (d > R) { isPhysicallyInside = false; isEffectivelyInside = false; break; }
                                        if (waferParams.type === 'flat') {
                                            const flatLen = parseNum(waferParams.flatLength);
                                            const flatH = Math.sqrt(R*R - (flatLen/2)**2);
                                            const ry = cr.x * sinR + cr.y * cosR;
                                            if (ry < -flatH) { isPhysicallyInside = false; isEffectivelyInside = false; break; }
                                        }
                                        if (d > validR) isEffectivelyInside = false;
                                        if (waferParams.type === 'flat') {
                                            const flatLen = parseNum(waferParams.flatLength);
                                            const flatH = Math.sqrt(R*R - (flatLen/2)**2);
                                            const ry = cr.x * sinR + cr.y * cosR;
                                            if (ry < -(flatH - exclusion)) isEffectivelyInside = false;
                                        }
                                    }
                                    if (isPhysicallyInside) { 
                                        let status = isEffectivelyInside ? 'good' : 'edge';
                                        if (status === 'good' && defectDensity > 0) {
                                            const area = group.w * group.h;
                                            const prob = 1 - Math.exp(-defectDensity * area);
                                            // USE DYNAMIC SEED FOR RANDOMNESS
                                            const rand = pseudoRandom(dieCenterX, dieCenterY, defectSeed); 
                                            if (rand < prob) status = 'defect';
                                        }

                                        if (isHighDensity) {
                                            if (!hdSummary[group.typeId]) hdSummary[group.typeId] = { label: group.label, valid: 0, edge: 0, defect: 0, color: resolveColor(group.colorIdx, group.customColor) };
                                            if (status === 'good') { hdSummary[group.typeId].valid++; hdTotalValid++; hdTotalDieArea += (group.w * group.h); } 
                                            else if (status === 'defect') { hdSummary[group.typeId].defect++; }
                                            else { hdSummary[group.typeId].edge++; hdTotalEdge++; }
                                        } else { 
                                            allDies.push({ ...group, x: dieCenterX, y: dieCenterY, status: status }); 
                                        }
                                    }
                                }
                            }
                        });
                    }
                }

                if (isHighDensity) {
                     const waferArea = Math.PI * R * R;
                     setStats({ summary: Object.values(hdSummary), totalValid: hdTotalValid, totalEdge: hdTotalEdge, totalDefect: 0, grossShots, utilization: waferArea > 0 ? (hdTotalDieArea / waferArea * 100) : 0, isHighDensity: true, isTooHeavy: false });
                } else {
                    calculatedDataRef.current = { dies: allDies, shots: allShots, waferR: R, validR, waferPoly, validPoly }; 
                    const summaryMap = {}; let totalValid = 0; let totalEdge = 0; let totalDefect = 0; let totalDieArea = 0;
                    allDies.forEach(d => {
                        if (!summaryMap[d.typeId]) {
                            const def = mode === 'single' ? { label: 'Single Die' } : dieDefinitions.find(x => x.id === d.typeId);
                            const resolvedColor = resolveColor(d.colorIdx, d.customColor);
                            summaryMap[d.typeId] = { label: def ? def.label : 'Unknown', valid: 0, edge: 0, defect: 0, color: resolvedColor };
                        }
                        if (d.status === 'good') { summaryMap[d.typeId].valid++; totalValid++; totalDieArea += (d.w * d.h); } 
                        else if (d.status === 'defect') { summaryMap[d.typeId].defect++; totalDefect++; }
                        else { summaryMap[d.typeId].edge++; totalEdge++; }
                    });
                    const waferArea = Math.PI * R * R;
                    setStats({ summary: Object.values(summaryMap), totalValid, totalEdge, totalDefect, grossShots, utilization: waferArea > 0 ? (totalDieArea / waferArea * 100) : 0, isHighDensity: false, isTooHeavy: false });
                    
                    allDies.forEach(d => {
                        let fillStyle, strokeStyle;
                        if (d.status === 'defect') {
                            fillStyle = DEFECT_COLOR.fill;
                            strokeStyle = DEFECT_COLOR.stroke;
                        } else {
                            const colorDef = resolveColor(d.colorIdx, d.customColor);
                            fillStyle = d.status === 'good' ? colorDef.fill : colorDef.fill + '60';
                            strokeStyle = d.status === 'good' ? (d.borderColor || colorDef.stroke) : '#ea580c';
                        }
                        const lw = (d.status === 'good' ? (d.borderWidth || 0.5) : 1) / finalScale;

                        ctx.beginPath(); ctx.rect(d.x - d.w/2, d.y - d.h/2, d.w, d.h);
                        ctx.fillStyle = fillStyle; ctx.fill(); 
                        ctx.strokeStyle = strokeStyle; ctx.lineWidth = lw; ctx.stroke();
                        
                        if (selectedDie && d.x === selectedDie.x && d.y === selectedDie.y) {
                            ctx.strokeStyle = '#06b6d4'; 
                            ctx.lineWidth = 3 / finalScale;
                            ctx.stroke();
                        }
                        
                        if (showLabels && (d.status === 'good' || d.status === 'defect')) { 
                            ctx.save();
                            ctx.translate(d.x, d.y);
                            ctx.scale(1, -1); 
                            ctx.fillStyle = d.status === 'defect' ? '#f1f5f9' : '#111827'; 
                            const fs = Math.min(d.w, d.h) * 0.5;
                            if (fs * finalScale > 6) { 
                                ctx.font = `${fs}px Arial`;
                                ctx.textAlign = 'center';
                                ctx.textBaseline = 'middle';
                                const labelText = (mode === 'single') ? `${d.shotC},${d.shotR}` : (d.label || '');
                                ctx.fillText(labelText, 0, 0);
                            }
                            ctx.restore();
                        }
                    });

                    if (mode === 'shot' && showShotGrid) {
                        ctx.strokeStyle = shotGridConfig.color;
                        ctx.lineWidth = (shotGridConfig.width || 1.5) / finalScale;
                        if (shotGridConfig.style === 'dashed') ctx.setLineDash([8 / finalScale, 4 / finalScale]); else ctx.setLineDash([]);
                        allShots.forEach(s => { ctx.beginPath(); ctx.rect(s.x - s.w/2, s.y - s.h/2, s.w, s.h); ctx.stroke(); });
                        ctx.setLineDash([]);
                    }
                    
                    if (showLabels) {
                         // Smart Axis Positioning
                         // Find max extent of valid grid or Wafer R
                         const gridExtentRight = (gridMaxX !== -Infinity) ? (gridMaxX * layoutStepX + startOffX + layoutStepX/2) : R;
                         const gridExtentTop = (gridMaxY !== -Infinity) ? (gridMaxY * layoutStepY + startOffY + layoutStepY/2) : R;
                         const gridExtentLeft = (gridMinX !== Infinity) ? (gridMinX * layoutStepX + startOffX - layoutStepX/2) : -R;
                         const gridExtentBottom = (gridMinY !== Infinity) ? (gridMinY * layoutStepY + startOffY - layoutStepY/2) : -R;

                         // The axis line should stay OUTSIDE the max extent of wafer or grid
                         const safeRight = Math.max(R, gridExtentRight) + 5;
                         const safeTop = Math.max(R, gridExtentTop) + 5;
                         const safeLeft = Math.min(-R, gridExtentLeft) - 5;
                         // const safeBottom = Math.min(-R, gridExtentBottom) - 5;
                         
                         const tickSize = 5 / finalScale;
                         
                         ctx.save();
                         ctx.lineWidth = 1 / finalScale;
                         ctx.strokeStyle = '#64748b'; 
                         ctx.fillStyle = '#64748b';
                         ctx.font = `${12/finalScale}px Arial`;
                         ctx.textAlign = 'center';
                         ctx.textBaseline = 'middle';
                         
                         // Top X Axis (Horizontal) - placed at safeTop
                         // Range: from gridMinX edge to gridMaxX edge
                         if (gridMinX !== Infinity && gridMaxX !== -Infinity) {
                             const axisStartX = gridMinX * layoutStepX + startOffX - layoutStepX/2;
                             const axisEndX = gridMaxX * layoutStepX + startOffX + layoutStepX/2;
                             
                             ctx.beginPath();
                             ctx.moveTo(axisStartX, safeTop); ctx.lineTo(axisEndX, safeTop);
                             ctx.stroke();

                             for(let c = gridMinX; c <= gridMaxX; c++) {
                                 const tx = c * layoutStepX + startOffX;
                                 const tickX = tx - layoutStepX / 2;
                                 ctx.beginPath(); ctx.moveTo(tickX, safeTop); ctx.lineTo(tickX, safeTop + tickSize); ctx.stroke();
                                 if (c === gridMaxX) {
                                     const endTickX = tx + layoutStepX / 2;
                                     ctx.beginPath(); ctx.moveTo(endTickX, safeTop); ctx.lineTo(endTickX, safeTop + tickSize); ctx.stroke();
                                 }
                                 // Number at Center
                                 ctx.save();
                                 ctx.translate(tx, safeTop + tickSize*3); 
                                 ctx.scale(1, -1); 
                                 ctx.fillText(`${c}`, 0, 0);
                                 ctx.restore();
                             }
                         }

                         // Left Y Axis (Vertical) - placed at safeLeft
                         // Range: from gridMinY edge to gridMaxY edge
                         if (gridMinY !== Infinity && gridMaxY !== -Infinity) {
                             const axisStartY = gridMinY * layoutStepY + startOffY - layoutStepY/2;
                             const axisEndY = gridMaxY * layoutStepY + startOffY + layoutStepY/2;

                             ctx.beginPath();
                             ctx.moveTo(safeLeft, axisStartY); ctx.lineTo(safeLeft, axisEndY);
                             ctx.stroke();

                             for(let r = gridMinY; r <= gridMaxY; r++) {
                                 const ty = r * layoutStepY + startOffY;
                                 const tickY = ty - layoutStepY / 2;
                                 ctx.beginPath(); ctx.moveTo(safeLeft, tickY); ctx.lineTo(safeLeft - tickSize, tickY); ctx.stroke();
                                 if (r === gridMaxY) {
                                     const endTickY = ty + layoutStepY / 2;
                                     ctx.beginPath(); ctx.moveTo(safeLeft, endTickY); ctx.lineTo(safeLeft - tickSize, endTickY); ctx.stroke();
                                 }
                                 // Number at Center
                                 ctx.save();
                                 ctx.translate(safeLeft - tickSize*4, ty);
                                 ctx.scale(1, -1);
                                 ctx.fillText(`${-r}`, 0, 0);
                                 ctx.restore();
                             }
                         }
                         ctx.restore();
                    }
                }
                
                const extLen = R + (2 * R * 0.1); 
                ctx.beginPath(); ctx.moveTo(-extLen, 0); ctx.lineTo(extLen, 0); ctx.moveTo(0, -extLen); ctx.lineTo(0, extLen); ctx.strokeStyle = 'rgba(0,0,0,0.5)'; ctx.lineWidth = 1 / finalScale; ctx.stroke();
            };

            calculateAndDrawRef.current = calculateAndDraw;

            // Helper must also use parseNum for flat length calculation (fixed MM)
            const generateWaferOutline = (radius, type, specValue, rotationDeg = 0) => {
                const points = []; const steps = 360; 
                const rotRad = rotationDeg * Math.PI / 180;
                
                const rotate = (p) => ({
                    x: p.x * Math.cos(rotRad) - p.y * Math.sin(rotRad),
                    y: p.x * Math.sin(rotRad) + p.y * Math.cos(rotRad)
                });

                if (type === 'flat') {
                    const flatLength = parseNum(specValue);
                    if (flatLength <= 0 || flatLength >= radius * 2) return generateCircle(radius).map(rotate); 
                    const alpha = Math.asin((flatLength / 2) / radius);
                    const arcSteps = 100;
                    const startRad = -Math.PI/2 + alpha; const endRad = 1.5*Math.PI - alpha;
                    for(let i=0; i<=arcSteps; i++) { 
                        const t = startRad + (endRad - startRad) * (i/arcSteps); 
                        points.push(rotate({ x: radius * Math.cos(t), y: radius * Math.sin(t) })); 
                    }
                    return points;
                } else if (type === 'notch') {
                    const notchD = 1.5; const notchW = 3; 
                    for(let i=0; i<=steps; i++) {
                        const theta = (i/steps)*2*Math.PI;
                        if (Math.abs(theta - 1.5*Math.PI) < 0.03) {
                            if (points[points.length-1]?.isNotch) continue;
                            points.push(rotate({ x: -notchW/2, y: -radius, isNotch: true })); 
                            points.push(rotate({ x: 0, y: -radius + notchD })); 
                            points.push(rotate({ x: notchW/2, y: -radius }));
                        } else { 
                            points.push(rotate({ x: radius * Math.cos(theta), y: radius * Math.sin(theta) })); 
                        }
                    }
                    return points;
                }
                return generateCircle(radius).map(rotate);
            };
            const generateCircle = (r) => { const p = []; for(let i=0; i<=128; i++) { const t = (i/128)*2*Math.PI; p.push({x: r*Math.cos(t), y: r*Math.sin(t)}); } return p; };

            useEffect(() => {
                const resizeObserver = new ResizeObserver(() => window.requestAnimationFrame(() => calculateAndDrawRef.current && calculateAndDrawRef.current()));
                if (containerRef.current) resizeObserver.observe(containerRef.current);
                return () => resizeObserver.disconnect();
            }, []);

            useEffect(() => { calculateAndDraw(); }, [waferParams, singleParams, shotParams, dieDefinitions, mode, showShotGrid, singleDieSettings, shotGridConfig, viewTransform, unit, showLabels, selectedDie, defectDensity, defectSeed]); 

            useEffect(() => { const handleClickOutside = (event) => { if (activeColorPicker && !event.target.closest('.style-picker-container')) setActiveColorPicker(null); }; document.addEventListener('mousedown', handleClickOutside); return () => document.removeEventListener('mousedown', handleClickOutside); }, [activeColorPicker]);
            
            useEffect(() => {
                if (selectedDie && containerRef.current) {
                    const container = containerRef.current;
                    const displaySizeW = container.clientWidth;
                    const displaySizeH = container.clientHeight;
                    const waferD = parseNum(waferParams.diameter);
                    const R = waferD / 2;
                    const baseScale = (Math.min(displaySizeW, displaySizeH) / 2) / (R * 1.05);
                    const finalScale = baseScale * viewTransform.k;
                    const screenX = (selectedDie.x * finalScale) + (displaySizeW/2 + viewTransform.x);
                    const screenY = (selectedDie.y * -finalScale) + (displaySizeH/2 + viewTransform.y);
                    setPopupPosition({ left: screenX, top: screenY });
                }
            }, [selectedDie, viewTransform, waferParams, containerRef.current]);

            const handleExportGDS = () => {
                if (stats.isHighDensity || stats.isTooHeavy) { alert("GDS Export is disabled in High Density Mode."); return; }
                const { dies, shots, waferR, validR, waferPoly, validPoly } = calculatedDataRef.current; 
                const writer = new GDSWriter(); const unitScale = 1000000; 
                writer.writeHeader(); writer.writeBgnLib(); writer.writeLibName("WAFER_MAP_LIB"); writer.writeUnits(); writer.writeBgnStr("WAFER_TOP");
                const toGdsPoints = (poly) => { const pts = []; poly.forEach(p => pts.push(Math.round(p.x * unitScale), Math.round(p.y * unitScale))); return pts; };
                if (waferPoly && waferPoly.length > 0) writer.writeBoundary(gdsLayers.wafer, 0, toGdsPoints(waferPoly));
                
                const cSize = waferR + (2 * waferR * 0.1); const cW = 0.1; 
                writer.writePath(gdsLayers.center, 0, Math.round(cW*unitScale), [Math.round(-cSize*unitScale), 0, Math.round(cSize*unitScale), 0]);
                writer.writePath(gdsLayers.center, 0, Math.round(cW*unitScale), [0, Math.round(-cSize*unitScale), 0, Math.round(cSize*unitScale), 0]);

                if (mode === 'shot') { shots.forEach(s => { const x1 = Math.round((s.x - s.w/2) * unitScale); const y1 = Math.round((s.y - s.h/2) * unitScale); const x2 = Math.round((s.x + s.w/2) * unitScale); const y2 = Math.round((s.y + s.h/2) * unitScale); writer.writeBoundary(gdsLayers.shot, 0, [x1, y1, x2, y1, x2, y2, x1, y2, x1, y1]); }); }
                dies.forEach(d => { 
                    let layer;
                    if (d.status === 'good') layer = gdsLayers.good;
                    else if (d.status === 'defect') layer = gdsLayers.defect;
                    else layer = gdsLayers.edge;
                    
                    const x1 = Math.round((d.x - d.w/2) * unitScale); const y1 = Math.round((d.y - d.h/2) * unitScale); const x2 = Math.round((d.x + d.w/2) * unitScale); const y2 = Math.round((d.y + d.h/2) * unitScale); 
                    writer.writeBoundary(layer, d.typeId, [x1, y1, x2, y1, x2, y2, x1, y2, x1, y1]); 
                });
                writer.writeEndStr(); writer.writeEndLib();
                const blob = writer.getBlob(); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = `wafer_map_${waferParams.diameter}mm.gds`; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
            };

            const handleExportExcel = () => {
                if (typeof XLSX === 'undefined') { alert("Excel library not loaded properly. Please check your internet connection."); return; }
                const wb = XLSX.utils.book_new();

                const uStr = unit==='mm'?' mm':' um';
                
                const infoRows = [
                    ["Parameter", "Value"],
                    ["Wafer Diameter", waferParams.diameter + " mm"],
                    ["Wafer Type", waferParams.type],
                    ["Orientation", waferParams.orientation + "°"],
                    ["Edge Exclusion", waferParams.edgeExclusion + " mm"],
                    ["Total Good Die", stats.totalValid],
                    ["Total Defect Die", stats.totalDefect],
                    ["Total Edge Die", stats.totalEdge],
                    ["Defect Density", defectDensity + " /mm²"],
                    ["Utilization", stats.utilization.toFixed(2) + "%"],
                    ["Mode", mode === 'single' ? "Single Die" : "Multi Die (MPW)"],
                ];

                if (waferParams.type === 'flat') {
                    infoRows.splice(4, 0, ["Flat Length", waferParams.flatLength + " mm"]);
                }

                if (mode === 'single') {
                    infoRows.push(
                        ["Die Width", singleParams.width + uStr],
                        ["Die Height", singleParams.height + uStr],
                        ["Scribe", singleParams.scribe + uStr],
                        ["Grid Offset X", singleParams.offsetX + uStr],
                        ["Grid Offset Y", singleParams.offsetY + uStr]
                    );
                } else {
                    infoRows.push(
                         ["Shot Width", shotParams.width + uStr],
                         ["Shot Height", shotParams.height + uStr],
                         ["Shot Offset X", shotParams.offsetX + uStr],
                         ["Shot Offset Y", shotParams.offsetY + uStr],
                         ["Scribe X", shotParams.scribeX + uStr],
                         ["Scribe Y", shotParams.scribeY + uStr]
                    );
                    infoRows.push(["", ""], ["Defined Die Groups", ""]);
                    dieDefinitions.forEach(d => {
                        infoRows.push([`Group: ${d.label}`, `${d.width}x${d.height}${uStr}, Array: ${d.rows}x${d.cols}`]);
                    });
                }

                const wsSummary = XLSX.utils.aoa_to_sheet(infoRows);
                wsSummary['!cols'] = [{ wch: 25 }, { wch: 30 }];
                XLSX.utils.book_append_sheet(wb, wsSummary, "Wafer Info");

                if (!stats.isTooHeavy && !stats.isHighDensity) {
                    const dies = calculatedDataRef.current.dies;
                    const u = unit==='mm'?'(mm)':'(um)';
                    // Reformat columns as requested
                    const headers = ["Index", "Name", "Type", "Shot Col", "Shot Row", `Center X ${u}`, `Center Y ${u}`, `Width ${u}`, `Height ${u}`];
                    const dieData = [headers];
                    dies.forEach((d, i) => {
                         const f = unit === 'um' ? 1000 : 1;
                         dieData.push([
                             i+1, 
                             d.label || 'Single', 
                             d.status,
                             d.shotC, d.shotR,
                             (d.x * f).toFixed(3), (d.y * f).toFixed(3),
                             (d.w * f).toFixed(3), (d.h * f).toFixed(3)
                         ]);
                    });
                    const wsDies = XLSX.utils.aoa_to_sheet(dieData);
                    XLSX.utils.book_append_sheet(wb, wsDies, "Die Coordinates");
                } else {
                     const wsInfo = XLSX.utils.aoa_to_sheet([["Note"], ["Die coordinates omitted due to high density (>100k) or calculation limit."]]);
                     XLSX.utils.book_append_sheet(wb, wsInfo, "Info");
                }

                XLSX.writeFile(wb, `WaferCalc_Report_${waferParams.diameter}mm.xlsx`);
            };

            const renderStylePicker = (id, currentSettings, updateBorderColor, updateBorderWidth, isShotGrid = false) => (
                <div className="relative style-picker-container"><button onClick={() => setActiveColorPicker(activeColorPicker === id ? null : id)} className="w-4 h-4 rounded border border-gray-300 shadow-sm hover:scale-110 transition-transform flex items-center justify-center" style={{ background: isShotGrid ? 'white' : currentSettings.fill }}>
                       {isShotGrid && <div className="w-2.5 h-2.5 rounded-sm" style={{ border: `1px ${currentSettings.style || 'solid'} ${currentSettings.borderColor}` }}></div>}
                    </button>
                    {activeColorPicker === id && (
                        <div className={`absolute ${isShotGrid ? 'right-0' : 'left-0'} top-6 z-50 bg-white border border-gray-200 shadow-xl rounded-lg p-3 w-56 flex flex-col gap-3`}>
                            {!isShotGrid && (
                            <div>
                                <div className="text-[10px] text-gray-500 mb-1 font-bold uppercase tracking-wider">Fill Color</div>
                                <div className="grid grid-cols-5 gap-2 mb-2">{PRESET_COLORS.map((c, idx) => ( <button key={idx} onClick={() => handlePresetSelect(id, idx)} className="w-6 h-6 rounded-full border border-gray-100 hover:scale-110 transition-transform shadow-sm" style={{ background: c.fill }} title={c.name} /> ))}</div>
                                <div className="flex items-center gap-2"><input type="color" value={currentSettings.fill} onChange={(e) => handleCustomColorSelect(id, e.target.value)} className="w-full h-6 cursor-pointer rounded border border-gray-200" /></div>
                            </div>
                            )}
                            <div className={!isShotGrid ? "border-t border-gray-100 pt-2" : ""}>
                                <div className="text-[10px] text-gray-500 mb-1 font-bold uppercase tracking-wider">{isShotGrid ? "Grid Line Style" : "Border Style"}</div>
                                <div className="flex items-center gap-2 mb-2">
                                    <span className="text-xs text-gray-600 w-12">Color</span>
                                    {/* For Shot Grid, preset selects stroke color directly. For Dies, it selects fill/stroke combo but here we just need color picker. */}
                                    <div className="flex-1 flex gap-1">
                                         {isShotGrid && PRESET_COLORS.slice(0,5).map((c, idx) => ( <button key={idx} onClick={() => handlePresetSelect(id, idx)} className="w-4 h-4 rounded-full border border-gray-100 hover:scale-110" style={{ background: c.stroke }} /> ))}
                                         <input type="color" value={currentSettings.borderColor || '#000000'} onChange={(e) => handleBorderColorSelect(id, e.target.value)} className="flex-1 h-6 cursor-pointer rounded border border-gray-200" />
                                    </div>
                                </div>
                                <div className="flex items-center gap-2 mb-2">
                                    <span className="text-xs text-gray-600 w-12">Width</span>
                                    <input type="number" step="0.1" value={currentSettings.borderWidth || 0.5} onChange={(e) => handleBorderWidthChange(id, e.target.value)} className="flex-1 h-6 px-1 text-xs border border-gray-300 rounded" />
                                </div>
                                {isShotGrid && (
                                     <div className="flex items-center gap-2">
                                        <span className="text-xs text-gray-600 w-12">Type</span>
                                        <select value={currentSettings.style} onChange={(e) => handleShotGridStyleChange(e.target.value)} className="flex-1 h-6 px-1 text-xs border border-gray-300 rounded bg-white">
                                            <option value="solid">Solid</option>
                                            <option value="dashed">Dashed</option>
                                        </select>
                                    </div>
                                )}
                            </div>
                        </div>
                    )}
                </div>
            );
            
            // Helper to get dies for list modal
            const getDiesForModal = (label) => {
                const dies = calculatedDataRef.current.dies.filter(d => (d.label || 'Single') === label);
                const f = unit === 'um' ? 1000 : 1;
                // Return copy with converted units
                return dies.map(d => ({
                    ...d,
                    x: d.x * f, y: d.y * f, w: d.w * f, h: d.h * f
                }));
            };

            return (
                <div className="flex h-screen w-full overflow-hidden bg-white">
                    {/* LEFT SIDEBAR: Parameters & Results */}
                    <div className="w-[360px] lg:w-[400px] flex-shrink-0 flex flex-col bg-white border-r border-gray-200 shadow-lg z-20">
                        {/* 1. App Header */}
                        <div className="p-3 border-b border-gray-200 bg-white">
                            <h1 className="text-2xl font-bold text-indigo-700 flex items-center gap-2"><Icons.Disc /> {T.title}</h1>
                        </div>

                        {/* 2. Scrollable Configuration Area */}
                        <div className="flex-1 overflow-y-auto p-3 space-y-4 custom-scroll bg-gray-50/50">
                            
                            {/* Section: Wafer Setup */}
                            <div className="space-y-2">
                                <h3 className="text-lg font-extrabold text-slate-700 flex items-center gap-2"><Icons.Settings /> {T.waferParams}</h3>
                                <div className="bg-white p-2.5 rounded-lg border border-gray-200 shadow-sm">
                                    <div className="grid grid-cols-2 gap-2 mb-2">
                                        <div>
                                            <label className="block text-xs font-medium text-gray-500 mb-0.5">{T.size}</label>
                                            <select value={waferParams.diameter} onChange={(e) => handleWaferChange('diameter', e.target.value)} className="block w-full py-1.5 px-2 border border-gray-300 rounded-md text-sm bg-gray-50 focus:ring-1 focus:ring-indigo-500">
                                                <option value="100">4 Inch (100mm)</option>
                                                <option value="150">6 Inch (150mm)</option>
                                                <option value="200">8 Inch (200mm)</option>
                                                <option value="300">12 Inch (300mm)</option>
                                            </select>
                                        </div>
                                        <div>
                                            <label className="block text-xs font-medium text-gray-500 mb-0.5">{T.waferType}</label>
                                            <select value={waferParams.type} onChange={(e) => handleWaferChange('type', e.target.value)} className="block w-full py-1.5 px-2 border border-gray-300 rounded-md text-sm bg-gray-50 focus:ring-1 focus:ring-indigo-500">
                                                <option value="notch">{T.notch}</option>
                                                <option value="flat">{T.flat}</option>
                                            </select>
                                        </div>
                                    </div>

                                    {/* Orientation and Exclusion */}
                                    <div className="grid grid-cols-2 gap-2 mb-0">
                                         <NumberInput label={T.orientation} value={waferParams.orientation} onChange={(v) => handleWaferChange('orientation', v)} suffix="°" />
                                         <NumberInput label={T.exclusion} value={waferParams.edgeExclusion} onChange={(v) => handleWaferChange('edgeExclusion', v)} />
                                    </div>

                                    {/* View Controls & Flat Length combined */}
                                    <div className="flex items-end gap-2 mt-2">
                                        {waferParams.type === 'flat' && (
                                            <div className="w-[100px]">
                                                <NumberInput label={T.flatLength} value={waferParams.flatLength} onChange={(v) => handleWaferChange('flatLength', v)} />
                                            </div>
                                        )}
                                        <div className="flex-1"></div>
                                        <ViewControls 
                                            unit={unit} onUnitChange={handleUnitSwitch} 
                                            showLabels={showLabels} onShowLabelsChange={setShowLabels} 
                                            bgColor={mapBgColor} onBgColorChange={setMapBgColor}
                                        />
                                    </div>
                                </div>
                            </div>

                            {/* Section: Shot Definition */}
                            <div className="space-y-2">
                                <h3 className="text-lg font-extrabold text-slate-700 flex items-center gap-2"><Icons.Grid /> {T.chipParams}</h3>
                                <div className="bg-white p-2.5 rounded-lg border border-gray-200 shadow-sm">
                                    
                                    {/* Mode Toggle */}
                                    <div className="flex bg-gray-100 p-0.5 rounded-md mb-3">
                                        <button onClick={() => setMode('single')} className={`flex-1 py-1.5 text-sm font-medium rounded-sm transition-all ${mode === 'single' ? 'bg-white shadow text-indigo-600' : 'text-gray-500 hover:text-gray-700'}`}>{T.singleMode}</button>
                                        <button onClick={() => setMode('shot')} className={`flex-1 py-1.5 text-sm font-medium rounded-sm transition-all ${mode === 'shot' ? 'bg-white shadow text-indigo-600' : 'text-gray-500 hover:text-gray-700'}`}>{T.shotMode}</button>
                                    </div>

                                    {mode === 'single' ? (
                                        <div className="space-y-2">
                                             <div className="flex items-center gap-2 pb-2 border-b border-gray-100">
                                                {renderStylePicker('single', 
                                                    { fill: resolveColor(singleDieSettings.colorIdx, singleDieSettings.customColor).fill, borderColor: singleDieSettings.borderColor, borderWidth: singleDieSettings.borderWidth },
                                                    handleBorderColorSelect, handleBorderWidthChange
                                                )}
                                                <span className="text-sm font-bold text-gray-700">Dimensions</span>
                                            </div>
                                            <div className="grid grid-cols-2 gap-2">
                                                <NumberInput label={labelWithUnit('width')} value={singleParams.width} onChange={v => handleSingleChange('width', v)} />
                                                <NumberInput label={labelWithUnit('height')} value={singleParams.height} onChange={v => handleSingleChange('height', v)} />
                                            </div>
                                            <div className="grid grid-cols-2 gap-2">
                                                <NumberInput label={labelWithUnit('gridOffsetX')} value={singleParams.offsetX} onChange={v => handleSingleChange('offsetX', v)} />
                                                <NumberInput label={labelWithUnit('gridOffsetY')} value={singleParams.offsetY} onChange={v => handleSingleChange('offsetY', v)} />
                                            </div>
                                            <NumberInput label={labelWithUnit('scribe')} value={singleParams.scribe} onChange={v => handleSingleChange('scribe', v)} />
                                            <div className="pt-1">
                                                <label className="block text-xs font-bold text-gray-400">Alignment</label>
                                                <AlignmentSelector mode={singleParams.offsetMode} onChange={(m) => handleSingleChange('offsetMode', m)} />
                                            </div>
                                        </div>
                                    ) : (
                                        <div className="space-y-2">
                                            <div className="grid grid-cols-2 gap-2">
                                                <NumberInput label={labelWithUnit('width')} value={shotParams.width} onChange={v => handleShotChange('width', v)} />
                                                <NumberInput label={labelWithUnit('height')} value={shotParams.height} onChange={v => handleShotChange('height', v)} />
                                            </div>
                                            <div className="grid grid-cols-2 gap-2">
                                                <NumberInput label={labelWithUnit('shotOffsetX')} value={shotParams.offsetX} onChange={v => handleShotChange('offsetX', v)} />
                                                <NumberInput label={labelWithUnit('shotOffsetY')} value={shotParams.offsetY} onChange={v => handleShotChange('offsetY', v)} />
                                            </div>
                                            <div className="grid grid-cols-2 gap-2">
                                                <NumberInput label={labelWithUnit('scribeX')} value={shotParams.scribeX} onChange={v => handleShotChange('scribeX', v)} />
                                                <NumberInput label={labelWithUnit('scribeY')} value={shotParams.scribeY} onChange={v => handleShotChange('scribeY', v)} />
                                            </div>
                                             
                                            {/* Alignment and Shot Grid Side by Side */}
                                            <div className="grid grid-cols-2 gap-3 pt-2 border-t border-gray-100 mt-2">
                                                <div>
                                                     <label className="block text-xs font-bold text-gray-400">Alignment</label>
                                                     <AlignmentSelector mode={shotParams.offsetMode} onChange={(m) => handleShotChange('offsetMode', m)} />
                                                </div>
                                                <div>
                                                    <div className="flex justify-between items-center mb-0.5">
                                                        <label className="block text-xs font-bold text-gray-400">Shot Grid</label>
                                                        <input type="checkbox" checked={showShotGrid} onChange={e => setShowShotGrid(e.target.checked)} className="w-3 h-3 text-indigo-600 rounded" title="Toggle Grid Visibility" />
                                                    </div>
                                                    <div className="flex items-center gap-2 mt-0.5 h-[26px]">
                                                        {renderStylePicker('shotGrid', {
                                                            borderColor: shotGridConfig.color,
                                                            borderWidth: shotGridConfig.width,
                                                            style: shotGridConfig.style
                                                        }, handleBorderColorSelect, handleBorderWidthChange, true)}
                                                        <span className="text-xs text-gray-500">Config</span>
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                    )}
                                </div>
                            </div>
                            
                            {/* Section: Die Groups (Only for Shot Mode) */}
                            {mode === 'shot' && (
                                <div className="space-y-2">
                                    <div className="flex justify-between items-center">
                                        <h3 className="text-lg font-extrabold text-slate-700 flex items-center gap-2"><Icons.Layers /> {T.mpwSettings}</h3>
                                        <button onClick={() => setDieDefinitions([...dieDefinitions, { id: Date.now(), label: 'New', width: '5', height: '5', offsetX: '0', offsetY: '0', rows: 1, cols: 1, gapX: 0, gapY: 0, colorIdx: dieDefinitions.length, customColor: null, borderColor: '#000000', borderWidth: 0.5 }])} className="text-xs text-indigo-600 font-bold bg-indigo-50 px-2 py-1 rounded hover:bg-indigo-100 transition flex items-center gap-1 border border-indigo-200">
                                            <Icons.Plus /> {T.addDie}
                                        </button>
                                    </div>
                                    
                                    <div className="space-y-2">
                                        {dieDefinitions.map((die) => (
                                            <div key={die.id} className="bg-white border border-gray-200 rounded-lg p-2.5 relative group hover:border-indigo-300 transition-colors shadow-sm">
                                                <button onClick={() => setDieDefinitions(prev => prev.length > 1 ? prev.filter(d => d.id !== die.id) : prev)} className="absolute right-2 top-2 text-gray-300 hover:text-red-500 transition-colors"><Icons.Trash2 /></button>
                                                
                                                <div className="flex items-center gap-2 mb-2 pr-6">
                                                    {renderStylePicker(die.id, 
                                                        { fill: resolveColor(die.colorIdx, die.customColor).fill, borderColor: die.borderColor, borderWidth: die.borderWidth },
                                                        handleBorderColorSelect, handleBorderWidthChange
                                                    )}
                                                    <input value={die.label} onChange={(e) => updateDieDef(die.id, 'label', e.target.value)} className="text-base font-bold w-full outline-none border-b border-transparent focus:border-indigo-300 placeholder-gray-300" placeholder="Label" />
                                                </div>

                                                <div className="grid grid-cols-2 gap-2 mb-2">
                                                    <NumberInput label={labelWithUnit('width')} value={die.width} onChange={val => updateDieDef(die.id, 'width', val)} />
                                                    <NumberInput label={labelWithUnit('height')} value={die.height} onChange={val => updateDieDef(die.id, 'height', val)} />
                                                </div>
                                                
                                                <details className="text-xs group/details">
                                                    <summary className="cursor-pointer text-gray-400 hover:text-indigo-600 font-medium list-none flex items-center gap-1 mt-1">
                                                        <span>Array & Position</span>
                                                        <svg className="w-3 h-3 transition-transform group-open/details:rotate-90" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M9 5l7 7-7 7" /></svg>
                                                    </summary>
                                                    <div className="pt-2 space-y-2">
                                                        <div className="grid grid-cols-2 gap-2">
                                                            <NumberInput label="Rows" value={die.rows} onChange={val => updateDieDef(die.id, 'rows', val)} />
                                                            <NumberInput label="Cols" value={die.cols} onChange={val => updateDieDef(die.id, 'cols', val)} />
                                                        </div>
                                                        <div className="grid grid-cols-2 gap-2">
                                                            <NumberInput label="Off X" value={die.offsetX} onChange={val => updateDieDef(die.id, 'offsetX', val)} />
                                                            <NumberInput label="Off Y" value={die.offsetY} onChange={val => updateDieDef(die.id, 'offsetY', val)} />
                                                        </div>
                                                        <div className="grid grid-cols-2 gap-2">
                                                            <NumberInput label="Gap X" value={die.gapX} onChange={val => updateDieDef(die.id, 'gapX', val)} />
                                                            <NumberInput label="Gap Y" value={die.gapY} onChange={val => updateDieDef(die.id, 'gapY', val)} />
                                                        </div>
                                                    </div>
                                                </details>
                                            </div>
                                        ))}
                                    </div>
                                </div>
                            )}

                            {/* Defect Density Setting */}
                            <div className="bg-white p-2.5 rounded-lg border border-gray-200 shadow-sm">
                                <NumberInput label={T.defectDensity} value={defectDensity} onChange={v => setDefectDensity(Math.max(0, parseFloat(v)))} step="0.0001" suffix="/mm²">
                                    <button onClick={() => setDefectSeed(Date.now())} className="p-1.5 text-gray-400 hover:text-indigo-600 hover:bg-gray-100 rounded transition-colors" title="Randomize Defects (Shuffle)">
                                        <Icons.Shuffle />
                                    </button>
                                </NumberInput>
                            </div>

                        </div>

                        {/* 3. Footer Summary (Sticky at Bottom) */}
                        <div className="p-3 bg-slate-900 text-white border-t border-slate-800 shadow-[0_-5px_15px_rgba(0,0,0,0.1)]">
                            <h3 className="text-base font-extrabold text-slate-400 mb-2 flex items-center gap-1"><Icons.AlertCircle /> {T.resultStats}</h3>
                            <div className="grid grid-cols-2 gap-4 mb-2">
                                <div>
                                    <div className="text-4xl font-bold text-emerald-400 leading-none">{stats.totalValid}</div>
                                    <div className="text-xs text-slate-400 mt-0.5 uppercase tracking-wide">Total Good Die</div>
                                </div>
                                <div>
                                    <div className="text-4xl font-bold text-orange-400 leading-none">{stats.totalEdge}</div>
                                    <div className="text-xs text-slate-400 mt-0.5 uppercase tracking-wide">Edge/Partial Die</div>
                                </div>
                            </div>
                            
                            {/* Utilization Bar */}
                            <div className="w-full bg-slate-800 h-1.5 rounded-full overflow-hidden mb-1">
                                <div className="bg-indigo-500 h-full transition-all duration-500" style={{width: `${Math.min(stats.utilization, 100)}%`}}></div>
                            </div>
                            <div className="flex justify-between text-xs text-slate-500">
                                <span>Area Utilization</span>
                                <span>{stats.utilization.toFixed(2)}%</span>
                            </div>
                        </div>
                    </div>

                    {/* RIGHT AREA: Wafer Map */}
                    <div className="flex-1 relative overflow-hidden flex flex-col transition-colors duration-300" style={{ backgroundColor: mapBgColor }}>
                        
                        {/* Map Toolbar (Top Right Overlay) */}
                        <div className="absolute top-4 right-4 z-10 flex gap-2 items-start">
                            <button onClick={handleExportExcel} className="bg-emerald-600 hover:bg-emerald-500 text-white border border-emerald-700/50 px-4 py-2 rounded-lg shadow-lg transition-all font-medium text-sm flex items-center gap-2 group whitespace-nowrap">
                                <Icons.Sheet /> <span className="hidden sm:inline">{T.exportExcel}</span>
                            </button>
                            
                            <div className="flex flex-col gap-2 min-w-[120px]">
                                <button onClick={handleExportGDS} className="w-full bg-slate-700 hover:bg-slate-600 text-white border border-slate-600 px-4 py-2 rounded-lg shadow-lg transition-all font-medium text-sm flex items-center justify-center gap-2 group whitespace-nowrap">
                                    <Icons.Download /> <span className="hidden sm:inline">{T.exportGDS}</span>
                                </button>
                                
                                {/* GDS Info Box */}
                                <div onClick={() => setShowLayerModal(true)} className="bg-slate-900 border border-slate-700 rounded-lg p-3 cursor-pointer hover:bg-slate-800 transition-colors shadow-lg w-full">
                                    <div className="text-xs text-slate-400 font-bold flex items-center justify-between mb-2">GDS Layers <Icons.Settings /></div>
                                    <div className="space-y-1 text-xs text-slate-300 font-mono">
                                        <div className="flex justify-between gap-2"><span>Wafer</span> <span>L{gdsLayers.wafer}</span></div>
                                        <div className="flex justify-between gap-2"><span>Good</span> <span>L{gdsLayers.good}</span></div>
                                        <div className="flex justify-between gap-2"><span>Edge</span> <span>L{gdsLayers.edge}</span></div>
                                        <div className="flex justify-between gap-2"><span>Defect</span> <span>L{gdsLayers.defect}</span></div>
                                        {mode === 'shot' && <div className="flex justify-between gap-2"><span>Shot</span> <span>L{gdsLayers.shot}</span></div>}
                                        <div className="flex justify-between gap-2"><span>Center</span> <span>L{gdsLayers.center}</span></div>
                                    </div>
                                </div>
                            </div>
                        </div>

                         {/* Map Legend Overlay */}
                         <div className="absolute top-4 left-4 z-10 pointer-events-none">
                            <div className="bg-slate-900 border border-slate-700 rounded-lg p-3 shadow-lg">
                                <div className="text-sm text-slate-400 font-bold mb-2">Yield Map</div>
                                {stats.summary.slice(0, 5).map((item, idx) => (
                                    <div key={idx} className="flex items-center gap-2 text-sm text-slate-200 mb-1">
                                        <span className="w-2 h-2 rounded-full" style={{ backgroundColor: item.color.fill }}></span>
                                        <span className="opacity-80">{item.label}:</span>
                                        <span className="font-bold">{item.valid}</span>
                                        {(defectDensity > 0 && item.defect > 0) && <span className="text-slate-500 ml-1">({item.defect} X)</span>}
                                    </div>
                                ))}
                                {(defectDensity > 0 && stats.totalDefect > 0) && (
                                    <div className="flex items-center gap-2 text-sm text-slate-200 mb-1 border-t border-slate-700 pt-1">
                                        <span className="w-2 h-2 rounded-full" style={{ backgroundColor: DEFECT_COLOR.fill }}></span>
                                        <span className="opacity-80">Total Defects:</span>
                                        <span className="font-bold">{stats.totalDefect}</span>
                                    </div>
                                )}
                            </div>
                        </div>

                        {/* Interactive Popup for Selected Die */}
                        {selectedDie && (
                            <div 
                                className="absolute z-30 bg-white/95 backdrop-blur rounded-lg shadow-2xl border border-indigo-100 p-3 popup-window w-48"
                                style={{
                                    left: popupPosition.left + 15,
                                    top: popupPosition.top + 15,
                                }}
                            >
                                <div className="flex items-center gap-2 mb-2 pb-1 border-b border-gray-100">
                                    <div className="w-3 h-3 rounded-full" style={{ background: selectedDie.status==='defect' ? DEFECT_COLOR.fill : resolveColor(selectedDie.colorIdx, selectedDie.customColor).fill }}></div>
                                    <button 
                                        onClick={() => setShowDieListModalLabel(selectedDie.label || 'Single')} 
                                        className="text-xs font-bold text-indigo-700 hover:underline cursor-pointer"
                                        title="View list of all dies"
                                    >
                                        {selectedDie.label || 'Die'}
                                    </button>
                                    <div className="ml-auto flex items-center gap-1">
                                        <button onClick={() => setSelectedDie(null)} className="text-gray-400 hover:text-red-500"><Icons.X /></button>
                                    </div>
                                </div>
                                <div className="space-y-1 text-[10px] text-gray-500">
                                    <div className="flex justify-between"><span>Type:</span> <span className="font-mono text-gray-700 capitalize">{selectedDie.status}</span></div>
                                    <div className="flex justify-between"><span>Shot:</span> <span className="font-mono text-gray-700">({selectedDie.shotC}, {selectedDie.shotR})</span></div>
                                    <div className="flex justify-between"><span>Size:</span> <span className="font-mono text-gray-700">{(selectedDie.w * (unit==='um'?1000:1)).toFixed(2)} x {(selectedDie.h * (unit==='um'?1000:1)).toFixed(2)} {unit}</span></div>
                                    <div className="flex justify-between"><span>Center X:</span> <span className="font-mono text-gray-700">{(selectedDie.x * (unit==='um'?1000:1)).toFixed(3)}</span></div>
                                    <div className="flex justify-between"><span>Center Y:</span> <span className="font-mono text-gray-700">{(selectedDie.y * (unit==='um'?1000:1)).toFixed(3)}</span></div>
                                </div>
                            </div>
                        )}

                        {/* Modals */}
                        {showDieListModalLabel && (
                            <DieListModal 
                                label={showDieListModalLabel} 
                                dies={getDiesForModal(showDieListModalLabel)} 
                                unit={unit}
                                onClose={() => setShowDieListModalLabel(null)} 
                            />
                        )}
                        {showLayerModal && (
                            <GDSLayerModal 
                                layers={gdsLayers} 
                                onUpdate={setGdsLayers} 
                                onClose={() => setShowLayerModal(false)} 
                            />
                        )}

                        {/* Canvas Area */}
                        <div 
                            ref={containerRef} 
                            className="w-full h-full cursor-grab active:cursor-grabbing relative"
                            onWheel={handleWheel}
                            onMouseDown={handleMouseDown}
                            onMouseMove={handleMouseMove}
                            onMouseUp={handleMouseUp}
                            onMouseLeave={handleMouseUp}
                        >
                            {/* Alerts */}
                            {stats.isHighDensity && !stats.isTooHeavy && (<div className="absolute inset-0 flex flex-col items-center justify-center pointer-events-none z-20"><div className="bg-slate-900 p-6 rounded-xl border border-orange-500/30 text-center shadow-2xl"><div className="text-orange-500 mb-2 flex justify-center"><Icons.AlertCircle /></div><h3 className="text-white font-bold mb-1">{T.highDensityMsg}</h3><p className="text-xs text-slate-300">{T.highDensityDesc}</p></div></div>)}
                            {stats.isTooHeavy && (<div className="absolute inset-0 flex flex-col items-center justify-center pointer-events-none z-20"><div className="bg-slate-900 p-6 rounded-xl border border-red-500/30 text-center shadow-2xl"><div className="text-red-500 mb-2 flex justify-center"><Icons.AlertCircle /></div><h3 className="text-white font-bold mb-1">{T.tooHeavyMsg}</h3><p className="text-xs text-slate-300">{T.tooHeavyDesc}</p></div></div>)}
                            
                            <canvas ref={canvasRef} className="block w-full h-full" />
                        </div>

                        {/* Bottom Right Zoom Controls & Branding */}
                        <div className="absolute bottom-6 right-6 z-10 flex flex-col items-end gap-2 pointer-events-none">
                            {/* Zoom Controls (Enable pointer events) */}
                            <div className="flex flex-col gap-2 bg-black/40 backdrop-blur-md p-1.5 rounded-lg border border-white/10 shadow-xl pointer-events-auto">
                                <button onClick={() => setViewTransform(p => ({...p, k: Math.min(p.k * 1.2, 50)}))} className="p-2 hover:bg-white/10 rounded text-slate-200 transition-colors" title="Zoom In"><Icons.ZoomIn /></button>
                                <button onClick={() => setViewTransform(p => ({...p, k: Math.max(p.k / 1.2, 0.1)}))} className="p-2 hover:bg-white/10 rounded text-slate-200 transition-colors" title="Zoom Out"><Icons.ZoomOut /></button>
                                <div className="w-full h-px bg-white/10 my-0.5"></div>
                                <button onClick={resetView} className="p-2 hover:bg-white/10 rounded text-slate-200 transition-colors" title={T.resetView}><Icons.RefreshCw /></button>
                            </div>
                            {/* Signature */}
                            <div className="text-[12px] text-slate-500 italic pr-1 select-none">
                                Design by <span className="font-bold">Peng Liu</span>
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<WaferCalculator />);
    </script>
</body>
</html>